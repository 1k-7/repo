import re
import time
import asyncio
from math import ceil
from hydrogram import Client, filters, enums
from hydrogram.errors import FloodWait, MessageNotModified
from hydrogram.types import InlineKeyboardMarkup, InlineKeyboardButton, CallbackQuery
from info import ADMINS, INDEX_EXTENSIONS, INDEX_CHANNELS # Use INDEX_CHANNELS if needed
from database.ia_filterdb import save_file # Assuming save_file is async
from utils import temp, get_readable_time
import logging

logger = logging.getLogger(__name__)
lock = asyncio.Lock()

# Global cache for status
index_status_cache = {"text": "Initializing...", "last_update": 0}

@Client.on_callback_query(filters.regex(r'^index'))
async def index_files_callback(bot, query: CallbackQuery):
    user_id = query.from_user.id
    # Only admins can start/cancel indexing
    if user_id not in ADMINS:
        return await query.answer("·¥è…¥ ü è ·¥Ä·¥Ö·¥ç…™…¥s ·¥Ñ·¥Ä…¥ ·¥ç·¥Ä…¥·¥Ä…¢·¥á …™…¥·¥Ö·¥áx…™…¥…¢.", show_alert=True)

    try:
        data_parts = query.data.split("#")
        if len(data_parts) != 5: raise ValueError("Incorrect callback data format")
        _, ident, chat, lst_msg_id_str, skip_str = data_parts
        lst_msg_id = int(lst_msg_id_str)
        skip = int(skip_str)
        # Handle chat ID (int or username string)
        try: chat_id_int = int(chat)
        except ValueError: chat_id_int = chat # Keep as string
    except (ValueError, IndexError) as e:
        logger.error(f"Error splitting index callback data '{query.data}': {e}")
        return await query.answer("Invalid callback data.", show_alert=True)

    if ident == 'yes':
        if lock.locked():
             return await query.answer("‚è≥ ·¥Ä…¥·¥è·¥õ ú·¥á Ä …™…¥·¥Ö·¥áx…™…¥…¢ …™s ·¥Ä ü Ä·¥á·¥Ä·¥Ö è …™…¥ ·¥ò Ä·¥è…¢ Ä·¥áss.", show_alert=True)
        msg = query.message
        await msg.edit("‚è≥ s·¥õ·¥Ä Ä·¥õ…™…¥…¢ …™…¥·¥Ö·¥áx…™…¥…¢...")
        # Start indexing in background, don't await here directly if it's long
        asyncio.create_task(index_files_to_db(lst_msg_id, chat_id_int, msg, bot, skip))
        await query.answer("Indexing started in background.", show_alert=False)
    elif ident == 'cancel':
        if not temp.CANCEL:
             temp.CANCEL = True
             logger.warning(f"User {user_id} requested indexing cancellation.")
             await query.message.edit("‚ùóÔ∏è ·¥õ Ä è…™…¥…¢ ·¥õ·¥è ·¥Ñ·¥Ä…¥·¥Ñ·¥á ü …™…¥·¥Ö·¥áx…™…¥…¢...")
             await query.answer("Cancellation request sent.", show_alert=False)
        else:
             await query.answer("Cancellation already requested.", show_alert=False)

@Client.on_message(filters.command('index') & filters.private & filters.user(ADMINS))
async def send_for_index(bot, message):
    if lock.locked():
        return await message.reply('‚è≥ ·¥Ä…¥·¥è·¥õ ú·¥á Ä …™…¥·¥Ö·¥áx…™…¥…¢ ·¥ò Ä·¥è·¥Ñ·¥áss …™s  Ä·¥ú…¥…¥…™…¥…¢. ·¥ò ü·¥á·¥Äs·¥á ·¥°·¥Ä…™·¥õ.')

    try:
        ask_msg = await message.reply("‚û°Ô∏è “ì·¥è Ä·¥°·¥Ä Ä·¥Ö ·¥õ ú·¥á  ü·¥Äs·¥õ ·¥ç·¥áss·¥Ä…¢·¥á (·¥°…™·¥õ ú «´·¥ú·¥è·¥õ·¥ás) ·¥è Ä s·¥á…¥·¥Ö ·¥õ ú·¥á  ü·¥Äs·¥õ ·¥ç·¥áss·¥Ä…¢·¥á  ü…™…¥·¥ã “ì Ä·¥è·¥ç ·¥õ ú·¥á ·¥Ñ ú·¥Ä…¥…¥·¥á ü.")
        response_msg = await bot.listen(chat_id=message.chat.id, user_id=message.from_user.id, timeout=120)
    except asyncio.TimeoutError: await ask_msg.edit("‚è∞ ·¥õ…™·¥ç·¥á·¥è·¥ú·¥õ."); return
    finally: try: await ask_msg.delete() except: pass

    chat_id = None; last_msg_id = None
    if response_msg.forward_from_chat and response_msg.forward_from_chat.type == enums.ChatType.CHANNEL:
        last_msg_id = response_msg.forward_from_message_id
        chat_id = response_msg.forward_from_chat.username or response_msg.forward_from_chat.id
    elif response_msg.text and response_msg.text.startswith(("https://t.me/", "http://t.me/")):
        msg_link = response_msg.text.strip()
        match = re.match(r"https?://t\.me/(?:c/)?(\w+)/(\d+)", msg_link)
        if match:
             channel_part = match.group(1); last_msg_id = int(match.group(2))
             try: chat_id = int(f"-100{channel_part}")
             except ValueError: chat_id = channel_part
        else: await response_msg.reply('‚ö†Ô∏è …™…¥·¥†·¥Ä ü…™·¥Ö  ü…™…¥·¥ã “ì·¥è Ä·¥ç·¥Ä·¥õ.'); return
    else: await response_msg.reply('‚ùå …¥·¥è·¥õ ·¥Ä ·¥†·¥Ä ü…™·¥Ö “ì·¥è Ä·¥°·¥Ä Ä·¥Ö ·¥è Ä  ü…™…¥·¥ã.'); return

    try:
        chat = await bot.get_chat(chat_id)
        if chat.type != enums.ChatType.CHANNEL: return await response_msg.reply("‚ùå ·¥è…¥ ü è ·¥Ñ ú·¥Ä…¥…¥·¥á üs ·¥Ñ·¥Ä…¥  ô·¥á …™…¥·¥Ö·¥áx·¥á·¥Ö.")
    except Exception as e: logger.error(f"Error getting chat {chat_id}: {e}"); return await response_msg.reply(f'‚ùå ·¥Ñ·¥è·¥ú ü·¥Ö …¥·¥è·¥õ ·¥Ä·¥Ñ·¥Ñ·¥áss ·¥Ñ ú·¥Ä…¥…¥·¥á ü.\n·¥á Ä Ä·¥è Ä: {e}')

    try:
        skip_ask_msg = await response_msg.reply("üî¢ ·¥á…¥·¥õ·¥á Ä …¥·¥ú·¥ç ô·¥á Ä ·¥è“ì ·¥ç·¥áss·¥Ä…¢·¥ás ·¥õ·¥è s·¥ã…™·¥ò (·¥á.…¢., `0`).")
        skip_response = await bot.listen(chat_id=message.chat.id, user_id=message.from_user.id, timeout=60)
    except asyncio.TimeoutError: await skip_ask_msg.edit("‚è∞ ·¥õ…™·¥ç·¥á·¥è·¥ú·¥õ."); return
    finally: try: await skip_ask_msg.delete() except: pass

    try: skip = int(skip_response.text.strip()); assert skip >= 0
    except (ValueError, AssertionError): await skip_response.reply("‚ùå …™…¥·¥†·¥Ä ü…™·¥Ö s·¥ã…™·¥ò …¥·¥ú·¥ç ô·¥á Ä."); return

    buttons = [[ InlineKeyboardButton('‚úÖ  è·¥ás', callback_data=f'index#yes#{chat_id}#{last_msg_id}#{skip}') ],
               [ InlineKeyboardButton('‚ùå …¥·¥è', callback_data='close_data') ]]
    await skip_response.reply(f'‚ùì …™…¥·¥Ö·¥áx `{chat.title}`?\n\n·¥õ·¥è·¥õ·¥Ä ü: ~<code>{last_msg_id}</code> | s·¥ã…™·¥ò: <code>{skip}</code>', reply_markup=InlineKeyboardMarkup(buttons))

# Helper
def get_progress_bar(percent, length=10):
    filled = int(length * percent / 100); unfilled = length - filled
    return '‚ñà' * filled + '‚ñí' * unfilled

# Main Indexing Function
async def index_files_to_db(lst_msg_id, chat, msg, bot, skip):
    total_files = 0; duplicate = 0; errors = 0; deleted = 0; no_media = 0; unsupported = 0
    BATCH_SIZE = 200; start_time = time.time(); last_edit_time = 0; EDIT_INTERVAL = 20 # Edit interval in seconds
    global index_status_cache

    # Ensure lock is acquired before proceeding
    if lock.locked():
         logger.warning("index_files_to_db called while lock was already held. This shouldn't happen.")
         # Optionally notify user or just return
         try: await msg.edit("‚ö†Ô∏è Indexing lock is already held. Please wait for the current process.")
         except: pass
         return

    async with lock: # Acquire lock
        try:
            current = skip; temp.CANCEL = False
            total_messages_in_channel = lst_msg_id
            total_fetch = total_messages_in_channel - current
            if total_fetch <= 0:
                 final_text = "üö´ …¥·¥è …¥·¥á·¥° ·¥ç·¥áss·¥Ä…¢·¥ás ·¥õ·¥è …™…¥·¥Ö·¥áx."; await msg.edit(final_text); index_status_cache = {"text": final_text, "last_update": time.time()}; return

            batches = ceil(total_fetch / BATCH_SIZE) if BATCH_SIZE > 0 else 0
            batch_times = []; status_callback_data = f'index_status#{chat}#{lst_msg_id}#{skip}'

            initial_edit = (f"‚è≥ …™…¥·¥Ö·¥áx…™…¥…¢ s·¥õ·¥Ä Ä·¥õ…™…¥…¢...\n~ s·¥ã…™·¥ò·¥ò…™…¥…¢ “ì…™ Äs·¥õ {current} ·¥ç·¥áss·¥Ä…¢·¥ás.")
            index_status_cache = {"text": initial_edit, "last_update": time.time()}

            try:
                await msg.edit(initial_edit, reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton('üìä s·¥õ·¥Ä·¥õ·¥ús', callback_data=status_callback_data)],
                    [InlineKeyboardButton('‚ùå ·¥Ñ·¥Ä…¥·¥Ñ·¥á ü', callback_data=f'index#cancel#{chat}#{lst_msg_id}#{skip}')]]))
                last_edit_time = time.time()
            except FloodWait as e: await asyncio.sleep(e.value); last_edit_time = time.time()

            # --- Batch Processing Loop ---
            for batch_num in range(batches):
                if temp.CANCEL: logger.warning("Cancellation requested, breaking index loop."); break
                batch_start_time = time.time()
                start_id = current + 1; end_id = min(current + BATCH_SIZE, lst_msg_id)
                message_ids = list(range(start_id, end_id + 1))
                if not message_ids: continue

                messages_in_batch = []
                try:
                    messages_in_batch = await bot.get_messages(chat, message_ids)
                    messages_in_batch = [m for m in messages_in_batch if m is not None]
                except FloodWait as e:
                     logger.warning(f"FloodWait on get_messages: sleep {e.value}s"); await asyncio.sleep(e.value);
                     try: messages_in_batch = await bot.get_messages(chat, message_ids); messages_in_batch = [m for m in messages_in_batch if m is not None]
                     except Exception as retry_e: errors += len(message_ids); current = end_id; logger.error(f"Retry fetch failed: {retry_e}"); continue
                except Exception as e: errors += len(message_ids); current = end_id; logger.error(f"Fetch batch error: {e}"); continue

                batch_processed_count = len(message_ids); batch_found_count = len(messages_in_batch)
                deleted += (batch_processed_count - batch_found_count)
                save_tasks = []

                for message in messages_in_batch:
                     if message.empty: continue
                     if not message.media: no_media += 1; continue
                     if message.media not in [enums.MessageMediaType.VIDEO, enums.MessageMediaType.AUDIO, enums.MessageMediaType.DOCUMENT]: unsupported += 1; continue
                     media = getattr(message, message.media.value, None)
                     if not media or not hasattr(media, 'file_name') or not media.file_name: unsupported += 1; continue
                     file_name_lower = media.file_name.lower()
                     if not any(file_name_lower.endswith("." + ext.lstrip('.')) for ext in INDEX_EXTENSIONS): unsupported += 1; continue
                     media.caption = message.caption
                     save_tasks.append(save_file(media)) # save_file is async

                if save_tasks:
                    results = await asyncio.gather(*save_tasks, return_exceptions=True)
                    for result in results:
                         if isinstance(result, Exception): errors += 1; logger.error(f"Save error: {result}")
                         elif result == 'suc': total_files += 1
                         elif result == 'dup': duplicate += 1
                         elif result == 'err': errors += 1
                current = end_id # Move position only after processing

                # --- Update Status Cache ---
                batch_time = time.time() - batch_start_time; batch_times.append(batch_time)
                elapsed = time.time() - start_time; progress = current - skip
                percentage = min((progress / total_fetch) * 100, 100.0) if total_fetch > 0 else 100.0
                avg_batch_time = sum(batch_times) / len(batch_times) if batch_times else 0.1 # Avoid div by zero
                remaining_messages = lst_msg_id - current
                remaining_batches = ceil(remaining_messages / BATCH_SIZE) if BATCH_SIZE > 0 else 0
                eta = remaining_batches * avg_batch_time
                progress_bar_str = get_progress_bar(int(percentage))
                status_text_for_cache = (
                     f"üìä …™…¥·¥Ö·¥áx…™…¥…¢ ·¥ò Ä·¥è…¢ Ä·¥áss\n\n"
                     f"‚ñ∑  ô·¥Ä·¥õ·¥Ñ ú: {batch_num + 1}/{batches}\n"
                     f"‚ñ∑ {progress_bar_str} {percentage:.1f}%\n"
                     f"‚ñ∑ “ì·¥á·¥õ·¥Ñ ú·¥á·¥Ö: {progress}/{total_fetch}\n"
                     f"‚ñ∑ s·¥Ä·¥†·¥á·¥Ö: {total_files} | ·¥Ö·¥ú·¥ò: {duplicate}\n"
                     f"‚ñ∑ ·¥Ö·¥á ü: {deleted} | ·¥ú…¥s·¥ú·¥ò: {no_media + unsupported}\n"
                     f"‚ñ∑ ·¥á Ä Ä·¥è Äs: {errors}\n"
                     f"‚ñ∑ ·¥á ü·¥Ä·¥ò: {get_readable_time(elapsed)}\n"
                     f"‚ñ∑ ·¥á·¥õ·¥Ä: {get_readable_time(eta)}"
                 )
                index_status_cache = {"text": status_text_for_cache, "last_update": time.time()}

                # --- Edit message less frequently ---
                current_time = time.time()
                if current_time - last_edit_time > EDIT_INTERVAL or batch_num == batches - 1:
                    edit_text = (f"‚è≥ …™…¥·¥Ö·¥áx…™…¥…¢... {progress_bar_str} {percentage:.1f}%\n"
                                f"~ {progress}/{total_fetch} ·¥ò Ä·¥è·¥Ñ·¥áss·¥á·¥Ö.")
                    try:
                        await msg.edit_text(text=edit_text, reply_markup=InlineKeyboardMarkup([
                            [InlineKeyboardButton('üìä s·¥õ·¥Ä·¥õ·¥ús', callback_data=status_callback_data)],
                            [InlineKeyboardButton('‚ùå ·¥Ñ·¥Ä…¥·¥Ñ·¥á ü', callback_data=f'index#cancel#{chat}#{lst_msg_id}#{skip}')]]))
                        last_edit_time = current_time
                    except FloodWait as e: await asyncio.sleep(e.value); last_edit_time = time.time()
                    except MessageNotModified: pass
                    except Exception as e_edit: logger.error(f"Edit error: {e_edit}")

            # --- Final Status ---
            elapsed = time.time() - start_time
            final_status_msg = "‚úÖ …™…¥·¥Ö·¥áx…™…¥…¢ ·¥Ñ·¥è·¥ç·¥ò ü·¥á·¥õ·¥á·¥Ö!" if not temp.CANCEL else "üõë …™…¥·¥Ö·¥áx…™…¥…¢ ·¥Ñ·¥Ä…¥·¥Ñ·¥á ü ü·¥á·¥Ö!"
            final_text_summary = (f"{final_status_msg}\n·¥õ·¥è·¥è·¥ã {get_readable_time(elapsed)}\n\n"
                                  f"‚ñ∑ ·¥ò Ä·¥è·¥Ñ·¥áss·¥á·¥Ö: {current - skip}\n"
                                  f"‚ñ∑ s·¥Ä·¥†·¥á·¥Ö: {total_files}\n"
                                  f"‚ñ∑ ·¥Ö·¥ú·¥ò ü…™·¥Ñ·¥Ä·¥õ·¥ás: {duplicate}\n"
                                  f"‚ñ∑ ·¥Ö·¥á ü/·¥ú…¥·¥Ä·¥†·¥Ä…™ ü: {deleted}\n"
                                  f"‚ñ∑ …¥·¥è…¥/·¥ú…¥s·¥ú·¥ò: {no_media + unsupported}\n"
                                  f"‚ñ∑ ·¥á Ä Ä·¥è Äs: {errors}")
            index_status_cache = {"text": final_text_summary, "last_update": time.time()}
            await msg.edit(final_text_summary, reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton('·¥Ñ ü·¥ès·¥á', callback_data='close_data')]]))

        except Exception as e:
            logger.exception(f"Fatal indexing error: {e}")
            final_error_text = f'‚ùå …™…¥·¥Ö·¥áx…™…¥…¢ ·¥á Ä Ä·¥è Ä: {e}'
            index_status_cache = {"text": final_error_text, "last_update": time.time()}
            try: await msg.edit(final_error_text, reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton('·¥Ñ ü·¥ès·¥á', callback_data='close_data')]]))
            except: pass # Ignore if msg edit fails on error
        finally:
            temp.CANCEL = False # Always reset cancel flag
            logger.info("Indexing process finished or cancelled.")
            # Lock is automatically released by 'async with'

# --- Status Button Callback ---
@Client.on_callback_query(filters.regex(r"^index_status"))
async def index_status_alert(bot, query: CallbackQuery):
    global index_status_cache
    last_updated_ago = time.time() - index_status_cache.get("last_update", time.time()) # Avoid error if no update yet
    status_text = index_status_cache.get("text", "s·¥õ·¥Ä·¥õ·¥ús …¥·¥è·¥õ  Ä·¥á·¥Ä·¥Ö è  è·¥á·¥õ.")
    update_info = f"\n\n(·¥ú·¥ò·¥Ö·¥Ä·¥õ·¥á·¥Ö: {int(last_updated_ago)}s ·¥Ä…¢·¥è)"

    try:
        await query.answer(text=status_text + update_info, show_alert=True, cache_time=2)
    except MessageTooLong: await query.answer("Status too long for alert.", show_alert=True)
    except Exception as e: logger.error(f"Index status alert error: {e}"); await query.answer("Error fetching status.", show_alert=True)
